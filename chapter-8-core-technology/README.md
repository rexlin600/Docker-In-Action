# 底层技术

Docker 使用 [Go 编程语言](https://golang.org/) 编写，并利用了 Linux 内核的多个功能来交付其功能。

Docker 的底层的核心技术如下四类：

* **命名空间（Namespaces）**： Docker 使用一种称为的技术`namespaces`来提供称为_容器_的隔离工作区；
* **控制组（Control Group）**： Linux上的Docker引擎还依赖于另一种称为_控制组_ （`cgroups`）的技术；
* **联合文件系统（Union FS）**：联合文件系统或UnionFS是通过创建图层进行操作的文件系统，使其非常轻便且快速；
* **容器格式**：Docker Engine 将命名空间、控制组、Union FS 组合到一个成为容器格式的包装器内， 默认容器格式为`libcontainer`。将来，Docker可以通过与 `BSD Jails` 或 `Solaris Zones` 等技术集成来支持其他容器格式。

下面，我们来分别来看下 Docker 的底层核心技术。

## 命名空间

Docker 和虚拟技术一样，从操作系统上实现了资源的隔离。它本质上是宿主机上的进程（容器进程），所以资源隔离只要就是指进程资源的隔离。实现资源隔离的核心技术就是 Linux namespace。

隔离意味着可以隔离出多个轻量级的内核（容器进程），这些进程可以充分利用宿主机的资源，宿主机有的资源容器进程都可以享有，但彼此之间也是隔离的、同样，不同容器之间使用资源也是隔离的，这样彼此之间进行相同的操作都不会相互干扰，安全性得到保障。

为了支持这些特性，Linux namespace 实现了 6 项资源隔离，基本涵盖了一个小型操作系统的运行要素，包括：主机名、用户权限、文件系统、网络、进程号、进程间通信等，如下图（图片来自互联网）：

![](../.gitbook/assets/image%20%2810%29.png)

这 6 项资源隔离分别对应 6 种系统调用，通过传入上表中的参数，调用 clone\(\) 函数来完成。

```text
Copyint clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);
```

clone\(\) 函数相信大家都不陌生了，它是 fork\(\) 函数更通用的实现方式，通过调用 clone\(\)，并传入需要隔离资源对应的参数，就可以建立一个容器了（隔离什么我们自己控制）。

一个容器进程也可以再 clone\(\) 出一个容器进程，这是容器的嵌套。

![](../.gitbook/assets/image%20%2811%29.png)

如果想要查看当前进程下有哪些 namespace 隔离，可以查看文件 /proc/\[pid\]/ns （注：该方法仅限于 3.8 版本以后的内核）。

## 控制组



## 联合文件系统





## 容器格式







