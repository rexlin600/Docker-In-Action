# 命名空间

> Docker 基础技术之 [命名空间](https://www.cnblogs.com/bakari/p/8560437.html)

Docker 和虚拟技术一样，从操作系统上实现了资源的隔离。它本质上是宿主机上的进程（容器进程），所以资源隔离只要就是指进程资源的隔离。实现资源隔离的核心技术就是 Linux namespace。

隔离意味着可以隔离出多个轻量级的内核（容器进程），这些进程可以充分利用宿主机的资源，宿主机有的资源容器进程都可以享有，但彼此之间也是隔离的、同样，不同容器之间使用资源也是隔离的，这样彼此之间进行相同的操作都不会相互干扰，安全性得到保障。

为了支持这些特性，Linux namespace 实现了 6 项资源隔离，基本涵盖了一个小型操作系统的运行要素，包括：**主机名**、**用户权限**、**文件系统**、**网络**、**进程号**、**进程间通信** 等，如下图（图片来自互联网）：

![](../.gitbook/assets/image%20%2810%29.png)

## 命名空间详解

### **pid 命名空间**

不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为Docker进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。

### **net 命名空间**

有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是**共享 host 的端口**。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 [veth](https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/) 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。

### **ipc 命名空间**

容器中进程交互还是采用了 Linux 常见的进程间交互方法\(interprocess communication - IPC\), 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。

### **mnt 命名空间**

类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。

### **uts 命名空间**

UTS\(“UNIX Time-sharing System”\) 命名空间允许每个容器拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。

### **user 命名空间**

每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。

## 底层原理

这 6 项资源隔离分别对应 6 种系统调用，通过传入上表中的参数，调用 clone\(\) 函数来完成。

```text
Copyint clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);
```

clone\(\) 函数相信大家都不陌生了，它是 fork\(\) 函数更通用的实现方式，通过调用 clone\(\)，并传入需要隔离资源对应的参数，就可以建立一个容器了（隔离什么我们自己控制）。

一个容器进程也可以再 clone\(\) 出一个容器进程，这是容器的嵌套：

![](../.gitbook/assets/image%20%2811%29.png)

如果想要查看当前进程下有哪些 namespace 隔离，可以查看文件 /proc/\[pid\]/ns （注：该方法仅限于 3.8 版本以后的内核）。

